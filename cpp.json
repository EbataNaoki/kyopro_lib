{
	"cin_vector_int":{
        "prefix": "cvi",
        "body":[
            "vector<int> $1($2);",
            "rep(i, $2, $3) cin >> $1[i];",
            "$3"
        ],
        "description": "vector<int>の受取"
	},
	
	"gcdlcm": {
		"prefix": "gcdlcm",
		"body": [
		  "ll gcd(ll a, ll b){",
		  "    if(a < b) return gcd(b, a);",
		  "    ll r = a % b;",
		  "    while(r != 0){",
		  "        a = b;",
		  "        b = r;",
		  "        r = a % b;",
		  "    }",
		  "    return b;",
		  "}",
		  "",
		  "ll lcm(ll a, ll b){",
		  "    ll ret = a / gcd(a,b) * b;",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },

	"is_prime": {
		"prefix": "isprime",
		"body": [
		  "bool is_prime(ll a){",
		  "    if(a == 1) return false;",
		  "    for(ll i=2; i*i<=a; i++){",
		  "        if(a%i == 0) return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": "identifying prime number of not"
	  },

	  "factorize": {
		"prefix": "factorize",
		"body": [
		  "vector<ll> factorize(ll g){",
		  "    if(g == 1){",
		  "        return {};",
		  "    }",
		  "    ll d = 2;",
		  "    vector<ll> ret;",
		  "    while(d*d <= g){",
		  "        if(g % d == 0){",
		  "            g /= d;",
		  "            while(g % d == 0){",
		  "                g /= d;",
		  "            }",
		  "            ret.push_back(d);",
		  "        }",
		  "        d++;",
		  "    }",
		  "    if(g != 1) ret.push_back(g);",
		  "    return ret;",
		  "}"
		],
		"description": "factorize"
	  },

	  "keta_sum": {
		"prefix": "ketasum",
		"body": [
		  "ll keta_sum(ll a){",
		  "    ll ret = 0;",
		  "    while(a > 0){",
		  "        ret += a%10;",
		  "        a /= 10;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "sum of digits"
	  },

	  "keta_bunkai": {
		"prefix": "ketabunkai",
		"body": [
		  "vector<ll> keta_bunkai(ll a){",
		  "    string s = to_string(a);",
		  "    vector<ll> ret;",
		  "    for(auto p : s){",
		  "        ret.push_back((ll)(p - '0'));",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "keta bunkai"
	  },

	  "distance": {
		"prefix": "dist",
		"body": [
		  "template<typename T> T dist(T x0, T y0, T x, T y){",
		  "    T ret = sqrt((x-x0)*(x-x0) + (y-y0)*(y-y0));",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": "distance between two grid point"
	  },
	  
	  "normal_nck": {
		"prefix": "normal_nck",
		"body": [
		  "ll gcd(ll a, ll b){",
		  "    if(a < b) return gcd(b, a);",
		  "    ll r = a % b;",
		  "    while(r != 0){",
		  "        a = b;",
		  "        b = r;",
		  "        r = a % b;",
		  "    }",
		  "    return b;",
		  "}",
		  "",
		  "ll nck(ll n, ll k){",
		  "  if (n < k) return 0;",
		  "  if (n < 0 || k < 0) return 0;",
		  "  if(k == 0 || k == n) return 1;",
		  "  ll nume = 1, deno = 1;",
		  "  for(int i=0; i<k; i++){",
		  "    nume *= (n-i);",
		  "    deno *= (i+1);",
		  "    ll g = gcd(nume, deno);",
		  "    nume /= g;",
		  "    deno /= g;",
		  "  }",
		  "  return (ll)(nume/deno);",
		  "}",
		  ""
		],
		"description": ""
	  },

	  "nck_mod_p": {
		"prefix": "kenchon_nck",
		"body": [
		  "const int MAX = 510000;",
		  "const int MOD = 1000000007;",
		  "",
		  "long long fac[MAX], finv[MAX], inv[MAX];",
		  "",
		  "// テーブルを作る前処理",
		  "void COMinit() {",
		  "    fac[0] = fac[1] = 1;",
		  "    finv[0] = finv[1] = 1;",
		  "    inv[1] = 1;",
		  "    for (int i = 2; i < MAX; i++){",
		  "        fac[i] = fac[i - 1] * i % MOD;",
		  "        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
		  "        finv[i] = finv[i - 1] * inv[i] % MOD;",
		  "    }",
		  "}",
		  "",
		  "// 二項係数計算",
		  "long long COM(int n, int k){",
		  "    if (n < k) return 0;",
		  "    if (n < 0 || k < 0) return 0;",
		  "    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
		  "}",
		  ""
		],
		"description": "mod nck"
	  },

	  "nck_mod": {
		"prefix": "nck_mod",
		"body": [
		  "ll mod = 1e9+7;",
		  "#define NMAX 200010",
		  "ll fac[NMAX];",
		  "ll inv[NMAX];",
		  "",
		  "ll mod_pow(ll a, ll n, ll mod){",
		  "    ll ret = 1;",
		  "    while(n > 0){",
		  "        if(n & 1) ret = (ret*(a % mod))%mod;",
		  "        a = ((a%mod)*(a%mod)) % mod;",
		  "        n = n >> 1;",
		  "    }",
		  "    return ret;",
		  "}",
		  "",
		  "ll mod_inv(ll a, ll mod){",
		  "    return mod_pow(a, mod-2, mod);",
		  "}",
		  "",
		  "void mae_nck(){",
		  "    fac[1] = 1;",
		  "    inv[1] = 1;",
		  "    for(ll i = 2; i < NMAX; i++){",
		  "        fac[i] = (fac[i-1] * i)%mod;",
		  "        inv[i] = (inv[i-1] * mod_inv(i, mod))%mod;",
		  "    }",
		  "}",
		  "",
		  "ll mod_nck(ll n, ll k){",
		  "    if (n < k) return 0;",
		  "    if (n < 0 || k < 0) return 0;",
		  "    if(k == 0 || k == n) return 1;",
		  "    ll ret = ((fac[n] * inv[k])%mod * inv[n-k])%mod;",
		  "    return ret;",
		  "}"
		],
		"description": "nck mod p"
	  },

	  "union find": {
		"prefix": "unionfind_snippets",
		"body": [
		  "typedef struct union_find {",
		  "    vector<ll> parent;",
		  "    vector<ll> nums;",
		  "    union_find(ll n){",
		  "        parent.resize(n);",
		  "        nums.resize(n, 1LL);",
		  "        rep(i, 0, n) parent[i] = i;",
		  "    }",
		  "",
		  "    ll root(ll x){",
		  "        if(parent[x] == x) return x;",
		  "        parent[x] = root(parent[x]);",
		  "        return parent[x];",
		  "    }",
		  "",
		  "    void unite(ll x, ll y){",
		  "        ll rx = root(x);",
		  "        ll ry = root(y);",
		  "        if(rx != ry){",
		  "            parent[rx] = ry;",
		  "            nums[ry] += nums[rx];",
		  "        }",
		  "    }",
		  "",
		  "    bool same(ll x, ll y){",
		  "        ll rx = root(x);",
		  "        ll ry = root(y);",
		  "        if(rx == ry) return true;",
		  "        return false;",
		  "    }",
		  "",
		  "    ll size(ll x){",
		  "        return nums[root(x)];",
		  "    }",
		  "} union_find;  "
		],
		"description": ""
	  },

	  "map_factorize": {
		"prefix": "map_factorize",
		"body": [
		  "map<ll, ll> factorize(ll g){",
		  "    map<ll, ll> ret;",
		  "    if(g == 1){",
		  "        ret[1]++;",
		  "        return ret;",
		  "    }",
		  "    ll d = 2;",
		  "    while(d*d <= g){",
		  "        if(g % d == 0){",
		  "            ret[d]++;",
		  "            g /= d;",
		  "            while(g % d == 0){",
		  "                ret[d]++;",
		  "                g /= d;",
		  "            }",
		  "        }",
		  "        d++;",
		  "    }",
		  "    if(g != 1) ret[g]++;",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "dist": {
		"prefix": "dist_line_point",
		"body": [
		  "double dist(double x1, double y1, double x2, double y2, double p, double q){",
		  "    double a = y2 - y1;",
		  "    double b = x2 - x1;",
		  "    double c = -x1*a + y1*b;",
		  "    double d = abs(a*p - b*q + c)/sqrt(a*a+b*b);",
		  "    return d;",
		  "}"
		],
		"description": "Calcurate the distance between a line and a point. The line is expressed by two points that are on the line."
	  },
	  "min_dga": {
		"prefix": "min_dag",
		"body": [
		  "/*",
		  "使い方",
		  "1. 以下をグローバル宣言",
		  "- ワーシャルフロイド用の2点間距離配列 d",
		  "- グラフ G",
		  "- 最短経路のみを持つDAG DAG",
		  "",
		  "2. dとGを初期化",
		  "- NOTE： 1-indexed",
		  "",
		  "3. make_dag(始点，終点，頂点数);",
		  "",
		  "たぶん O(N^3)",
		  "*/",
		  "",
		  "vector<vector<ll>> DAG, d, G;",
		  "",
		  "void make_dag(ll A, ll B, ll N){",
		  "    ",
		  "    //　ワーシャルフロイド",
		  "    rep(i, 1, N+1) d[i][i] = 0;",
		  "    rep(i, 1, N+1){",
		  "        rep(j, 1, N+1){",
		  "            rep(k, 1, N+1){",
		  "                d[j][k] = min(d[j][k], d[j][i] + d[i][k]);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    // 最短経路のみのDAG作成",
		  "    DAG.resize(N+1);",
		  "    queue<ll> que;",
		  "    vector<bool> seen(N+1, false);",
		  "    que.push(A);",
		  "    while(!que.empty()){",
		  "        auto t = que.front();",
		  "        que.pop();",
		  "        if(seen[t]) continue;",
		  "        seen[t] = true;",
		  "        for(auto g : G[t]){",
		  "            if(d[A][t] + 1 + d[g][B] == d[A][B]){",
		  "                DAG[t].push_back(g);",
		  "                que.push(g);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "warshall": {
		"prefix": "warshall",
		"body": [
		  "void warshallFloyed(vector<vector<ll>> &d) {",
		  "    ll n = d.size();",
		  "    for(int i = 0; i < n; i++) d[i][i] = 0;",
		  "    for(int i = 0; i < n; i++) {",
		  "        for(int j = 0; j < n; j++) {",
		  "            for(int k = 0; k < n; k++) {",
		  "                d[j][k] = min(d[j][k], d[j][i] + d[i][k]);",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "plus_templates": {
		"prefix": "plustemplate",
		"body": [
		  "#define VL vector<ll>",
		  "#define VS vector<string>",
		  "#define VB vector<bool>",
		  "#define VP vector<pair<ll,ll>>",
		  "#define VVL vector<vector<ll>>",
		  "#define VVP vector<vector<pair<ll,ll>>>",
		  "#define PL pair<ll,ll>",
		  "#define ALL(v) (v).begin(), (v).end()",
		  "ll d1[4] = {1, -1, 0, 0};",
		  "ll d2[4] = {0, 0, 1, -1};"
		],
		"description": ""
	  },
	  "yakusu": {
		"prefix": "yakusu",
		"body": [
		  "vector<ll> yakusu(ll n){",
		  "    vector<ll> ret;",
		  "    for(ll i = 1; i*i <= n; i++){",
		  "        if(n % i != 0) continue;",
		  "        ret.push_back(i);",
		  "        if(i*i != n) ret.push_back(n/i);",
		  "    }",
		  "    sort(ret.begin(), ret.end());",
		  "    return ret;",
		  "}"
		],
		"description": "all of yakusu"
	  },
	  "dijkstra": {
		"prefix": "dijkstra",
		"body": [
		  "/*",
		  "    ll N, M; cin >> N >> M;",
		  "    vector<vector<pair<ll,ll>>> G(N+1);",
		  "    rep(i, 0, M){",
		  "        ll v, u, w;",
		  "        cin >> v >> u >> w;",
		  "        G[u].push_back({v, w});",
		  "        G[v].push_back({u, w});",
		  "    }",
		  "",
		  "    ll srt = 1;",
		  "    vector<ll> d(N+1, 1e18);",
		  "    */",
		  "   ",
		  "    /* dijkstra's scope */{",
		  "        priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>>> que;",
		  "        que.push({0, srt});",
		  "        d[srt] = 0;",
		  "        while(!que.empty()){",
		  "            auto q = que.top();",
		  "            que.pop();",
		  "            if(q.first > d[q.second]) continue;",
		  "            for(auto g : G[q.second]){",
		  "                if(d[g.first] <= q.first + g.second) continue;",
		  "                d[g.first] = q.first + g.second;",
		  "                que.push({d[g.first], g.first});",
		  "            }",
		  "        }",
		  "    }"
		],
		"description": "dijkstra"
	  },
	  "prime factorize": {
		"prefix": "prime_factorize",
		"body": [
		  "vector<pair<ll,ll>> prime_factorize(ll N){",
		  "    vector<pair<ll,ll>> ret;",
		  "    for(ll a = 2; a * a <= N; a++){",
		  "        if(N % a != 0) continue;",
		  "        ll ex = 0;",
		  "        while(N % a == 0){",
		  "            ex++;",
		  "            N /= a;",
		  "        }",
		  "        ret.push_back({a, ex});",
		  "    }",
		  "    if(N != 1) ret.push_back({N, 1});",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },
	  "Z-algorithm": {
		"prefix": "Zalgo",
		"body": [
		  "vector<ll> Zalgo(string S){",
		  "    ll N = S.size();",
		  "    vector<ll> ret(N);",
		  "    ret[0] = N;",
		  "    ll i = 1, j = 0;",
		  "    while(i < N){",
		  "        while(i + j < N && S[j] == S[i+j]) j++;",
		  "        ret[i] = j;",
		  "        if(j == 0){",
		  "            i++;",
		  "            continue;",
		  "        }",
		  "        ll k = 1;",
		  "        while(i + k < N && k + ret[k] < j){",
		  "            ret[i+k] = ret[k];",
		  "            k++;",
		  "        }",
		  "        i += k;",
		  "        j -= k;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },
	  "PI": {
		"prefix": "PI",
		"body": [
		  "constexpr double PI=3.14159265358979323846;"
		],
		"description": ""
	  },
	  "fenwick tree": {
		"prefix": "BIT",
		"body": [
		  "#define FENWICK_NMAX 200010",
		  "struct fenwick_tree{",
		  "    ll N;",
		  "    ll bit[FENWICK_NMAX];",
		  "    fenwick_tree(ll n){",
		  "        N = n;",
		  "        for(ll x = 1; x <= N; x++){",
		  "            bit[x] = 0;",
		  "        }",
		  "    }",
		  "    void add(ll a, ll w){",
		  "        for(ll x = a; x <= N; x += x & -x){",
		  "            bit[x] += w;",
		  "        }",
		  "    }",
		  "    ll sum(ll a){",
		  "        ll ret = 0;",
		  "        for(ll x = a; x > 0; x -= x & -x){",
		  "            ret += bit[x];",
		  "        }",
		  "        return ret;",
		  "    }",
		  "};"
		],
		"description": "fenwick tree"
	  },
	  "bellman_ford_snippets": {
		"prefix": "bellman_ford_snippets",
		"body": [
		  "namespace bellman {",
		  "",
		  "    const ll inf = 1LL<<60;",
		  "",
		  "    typedef struct EdgeInfo{",
		  "        ll from;",
		  "        ll to;",
		  "        ll cost;",
		  "        EdgeInfo() {};",
		  "        EdgeInfo(ll _from, ll _to, ll _cost) : from(_from), to(_to), cost(_cost) {};",
		  "    } edge;",
		  "",
		  "    vector<pair<ll,bool>> bellman_ford(ll n, vector<edge> E) {",
		  "        ",
		  "        ll m = E.size();",
		  "        vector<ll> d(n, inf);",
		  "        ",
		  "        // グラフ全体での負経路検出",
		  "        bool closed_loop = false;",
		  "",
		  "        ll srt = 0;",
		  "        d[srt] = 0;",
		  "        rep(i, 0, n){",
		  "            rep(j, 0, m){",
		  "                auto e = E[j];",
		  "                if(d[e.to] > d[e.from] + e.cost){",
		  "                    d[e.to] = d[e.from] + e.cost;",
		  "                    if(i == n-1){",
		  "                        closed_loop = true;",
		  "                        break;",
		  "                    }",
		  "                }",
		  "            }",
		  "            if(closed_loop) break;",
		  "        }",
		  "",
		  "        vector<pair<ll,bool>> res(n);",
		  "        rep(i, 0, n) res[i].first = d[i];",
		  "",
		  "        // 各頂点への経路中の負閉路検出",
		  "        vector<bool> neg(n, false);",
		  "",
		  "        rep(loop, 0, n) {",
		  "            rep(i, 0, m) {",
		  "                auto e = E[i];",
		  "                if(d[e.from] == inf) continue;",
		  "                if(d[e.to] > d[e.from] + e.cost) {",
		  "                    d[e.to] = d[e.from] + e.cost;",
		  "                    neg[e.to] = true;",
		  "                }",
		  "                if(neg[e.from]) neg[e.to] = true;",
		  "            }",
		  "        }",
		  "",
		  "        rep(i, 0, n) res[i].second = neg[i];",
		  "        return res;",
		  "    }",
		  "    // res.second == true のとき，答えは無限に小さくなりえる．",
		  "};"
		],
		"description": ""
	  },
	  "baisu": {
		"prefix": "baisu",
		"body": [
		  "// low以上high以下のbaseの倍数の数",
		  "ll baisu(ll base, ll low, ll high){",
		  "    ll bt = (low + base - 1) / base;",
		  "    ll up = high / base;",
		  "    return up - bt + 1;",
		  "}"
		],
		"description": ""
	  },
	  "RMQ": {
		"prefix": "RMQ",
		"body": [
		  "",
		  "template <typename T> struct RMQ{",
		  "    ",
		  "    const ll NMAX = 1 << 17; // 131072",
		  "    const ll LL_MAX = 1e18 + 20;",
		  "    ll n;",
		  "    vector<T> dat;",
		  "",
		  "    RMQ(ll _n){",
		  "        n = 1;",
		  "        // 2^pまでpaddingする",
		  "        while(n < _n) n *= 2;",
		  "        // 初期化",
		  "        dat.resize((2 * NMAX - 1), LL_MAX);",
		  "    }",
		  "",
		  "    RMQ(ll _n, T _ini_val){",
		  "        n = 1;",
		  "        // 2^pまでpaddingする",
		  "        while(n < _n) n *= 2;",
		  "        // 初期化",
		  "        dat.resize((2 * NMAX - 1), LL_MAX);",
		  "        for(ll i = 0; i < 2 * n - 1; i++) dat[i] = _ini_val;",
		  "    }",
		  "",
		  "    void update(ll k, T a){",
		  "        k += n - 1;",
		  "        dat[k] = a;",
		  "        while(k > 0){",
		  "            k = (k-1) / 2;",
		  "            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);",
		  "        }",
		  "    }",
		  "",
		  "    T query(ll a, ll b, ll k, ll l, ll r){",
		  "        // [a, b) の最小値を求める．",
		  "        // k := nodeの番号",
		  "        // kが[l, r)に対応している．",
		  "        // query(a, b, 0, 0, n)で外から呼ぶ",
		  "        ",
		  "        // [a, b)と[l，r)が交差しないケース",
		  "        if(r <= a || b <= l){",
		  "            return LL_MAX;",
		  "        }",
		  "",
		  "        if(a <= l && r <= b){",
		  "            // [a, b)を[l, r)含むケース",
		  "            return dat[k];",
		  "        }else{",
		  "            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);",
		  "            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);",
		  "            return min(vl, vr);",
		  "        }",
		  "    }",
		  "    ",
		  "    T query(ll a, ll b){",
		  "        return query(a, b, 0, 0, n);",
		  "    }",
		  "",
		  "};",
		  "/*",
		  "int main(){",
		  "    ll N, Q;",
		  "    cin >> N >> Q;",
		  "    RMQ<ll> sg(N, (1LL<<31) - 1);",
		  "    rep(q, 0, Q){",
		  "        ll comm, x, y;",
		  "        cin >> comm >> x >> y;",
		  "        if(comm == 0) sg.update(x, y);",
		  "        else cout << sg.query(x, y+1) << endl;",
		  "    }",
		  "    return 0;",
		  "}",
		  "*/"
		],
		"description": ""
	  },
	  "Segment_tree_kenchyon": {
		"prefix": "segmenttree",
		"body": [
		  "template<class Monoid> struct SegTree {",
		  "    using Func = function<Monoid(Monoid, Monoid)>;",
		  "    const Func F;",
		  "    const Monoid UNITY;",
		  "    int SIZE_R;",
		  "    vector<Monoid> dat;",
		  "    ",
		  "    SegTree(int n, const Func f, const Monoid &unity): F(f), UNITY(unity) { init(n); }",
		  "    void init(int n) {",
		  "        SIZE_R = 1;",
		  "        while (SIZE_R < n) SIZE_R *= 2;",
		  "        dat.assign(SIZE_R * 2, UNITY);",
		  "    }",
		  "    ",
		  "    /* set, a is 0-indexed */",
		  "    void set(int a, const Monoid &v) { dat[a + SIZE_R] = v; }",
		  "    void build() {",
		  "        for (int k = SIZE_R - 1; k > 0; --k)",
		  "            dat[k] = F(dat[k*2], dat[k*2+1]);",
		  "    }",
		  "    ",
		  "    /* update, a is 0-indexed */",
		  "    void update(int a, const Monoid &v) {",
		  "        int k = a + SIZE_R;",
		  "        dat[k] = v;",
		  "        while (k >>= 1) dat[k] = F(dat[k*2], dat[k*2+1]);",
		  "    }",
		  "    ",
		  "    /* get {min-value, min-index}, a and b are 0-indexed */",
		  "    Monoid get(int a, int b) {",
		  "        Monoid vleft = UNITY, vright = UNITY;",
		  "        for (int left = a + SIZE_R, right = b + SIZE_R; left < right; left >>= 1, right >>= 1) {",
		  "            if (left & 1) vleft = F(vleft, dat[left++]);",
		  "            if (right & 1) vright = F(dat[--right], vright);",
		  "        }                                                                                                              ",
		  "        return F(vleft, vright);",
		  "    }",
		  "    inline Monoid operator [] (int a) { return dat[a + SIZE_R]; }",
		  "    ",
		  "    /* debug */",
		  "    void print() {",
		  "        for (int i = 0; i < SIZE_R; ++i) {",
		  "            cout << (*this)[i];",
		  "            if (i != SIZE_R-1) cout << \",\";",
		  "        }",
		  "        cout << endl;",
		  "    }",
		  "};",
		  ""
		],
		"description": ""
	  },
	  "line_cross_check": {
		"prefix": "line_cross",
		"body": [
		  "typedef struct Point_Coordinates {",
		  "    double x, y;",
		  "} point;",
		  "",
		  "// 線分ab, cdが交差する場合True",
		  "// 端点が他方の線分上にある場合もTrue",
		  "bool judge(point a, point b, point c, point d){",
		  "    double s, t;",
		  "    s = (a.x - b.x) * (a.y - c.y) - (a.y - b.y) * (a.x - c.x);",
		  "    t = (a.x - b.x) * (a.y - d.y) - (a.y - b.y) * (a.x - d.x);",
		  "    if (s * t >= 0) return false;",
		  "",
		  "    s = (c.x - d.x) * (c.y - a.y) - (c.y - d.y) * (c.x - a.x);",
		  "    t = (c.x - d.x) * (c.y - b.y) - (c.y - d.y) * (c.x - b.x);",
		  "    if (s * t >= 0) return false;",
		  "    ",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "LCS": {
		"prefix": "LCS",
		"body": [
		  "string LCS(string s, string t){",
		  "    ll ns = s.size();",
		  "    ll nt = t.size();",
		  "    vector< vector<ll> > dp(ns+1, vector<ll> (nt+1, 0));",
		  "    // initilaize",
		  "    rep(i, 0, ns){",
		  "        if(s[i] == t[0]) dp[i][0] = 1;",
		  "    }",
		  "    rep(i, 0, nt){",
		  "        if(s[0] == t[i]) dp[0][i] = 1;",
		  "    }",
		  "    // build DP table",
		  "    rep(i, 1, ns){",
		  "        rep(j, 1, nt){",
		  "            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);",
		  "            if(s[i] == t[j]){",
		  "                dp[i][j] = dp[i-1][j-1] + 1;",
		  "            }",
		  "        }",
		  "    }",
		  "    // make LCS",
		  "    string ret;",
		  "    ll i = ns-1, j = nt-1;",
		  "    while(i >= 0 && j >= 0){",
		  "        if(s[i] == t[j]){",
		  "            ret.push_back(s[i]);",
		  "            i--; j--;",
		  "        }else{",
		  "            if(j == 0) i--;",
		  "            else if(i == 0) j--;",
		  "            else if(dp[i-1][j] > dp[i][j-1]) i--;",
		  "            else j--;",
		  "        }",
		  "    }",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "2bugraph": {
		"prefix": "2bugraph",
		"body": [
		  "// 2部グラフの判定",
		  "// 使い方：colorを-1で初期化してください．",
		  "// 注意：連結かどうかに気をつけてください．",
		  "// 参考：https://qiita.com/drken/items/a803d4fc4a727e02f7ba#4-3-%E4%BA%8C%E9%83%A8%E3%82%B0%E3%83%A9%E3%83%95%E5%88%A4%E5%AE%9A",
		  "vector<ll> color;",
		  "bool is_2bu_graph(vector< vector<ll> >& G, ll now, ll col) {",
		  "    color[now] = col;",
		  "    for(auto g : G[now]) {",
		  "        if(color[g] != -1) {",
		  "            if(color[g] == col) return false;",
		  "            else continue;",
		  "        } else {",
		  "            if(!is_2bu_graph(G, g, 1-col)) return false;",
		  "        }",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "centroid_snippets": {
		"prefix": "centroid_snippets",
		"body": [
		  "/*-------------ここから---------------*/",
		  "using _ll = long long;",
		  "vector<_ll> _max_subtree, _sum_subtree;",
		  "_ll _centroid1(vector<vector<_ll>>& G, _ll cur, _ll par, _ll N) {",
		  "    _ll mx = 0, sum = 0;",
		  "    for(auto g : G[cur]) {",
		  "        if(g == par) continue;",
		  "        _ll tmp = _centroid1(G, g, cur, N);",
		  "        sum += tmp;",
		  "        mx = max(mx, tmp);",
		  "    }",
		  "    mx = max(mx, N - sum - 1);",
		  "    _max_subtree[cur] = mx;",
		  "    _sum_subtree[cur] = sum;",
		  "    return sum + 1;",
		  "}",
		  "vector<_ll> _centroid2(_ll N) {",
		  "    vector<_ll> res;",
		  "    _ll mn = 1LL<<60;",
		  "    for(_ll i = 0; i < N; i++) mn = min(mn, _max_subtree[i]);",
		  "    for(_ll i = 0; i < N; i++) if(_max_subtree[i] == mn) res.push_back(i);",
		  "    return res;",
		  "}",
		  "vector<_ll> find_centroids(vector<vector<_ll>>& G, _ll N) {",
		  "    _max_subtree = vector<_ll>(N, 0);",
		  "    _sum_subtree = vector<_ll>(N, 0);",
		  "    _centroid1(G, 0, -1, N);",
		  "    return _centroid2(N);",
		  "}",
		  "/*-------------ここまで---------------*/"
		],
		"description": ""
	  },

	  "compare string": {
		"prefix": "string_comp",
		"body": [
		  "// a >= b ?",
		  "const string MININF = \"-\";",
		  "bool comp(string a, string b){",
		  "    if(b == MININF) return true;",
		  "    if(a == MININF) return false;",
		  "    if(a.size() > b.size()) return true;",
		  "    if(a.size() < b.size()) return false;",
		  "    rep(i, 0, a.size()){",
		  "        if(a[i] > b[i]) return true;",
		  "        if(a[i] < b[i]) return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "kruskal_snippet": {
		"prefix": "kruskal_snippet",
		"body": [
		  "/*---------------ここから---------------*/",
		  "namespace kruskal {",
		  "",
		  "    using ll = long long;",
		  "",
		  "    typedef struct union_find {",
		  "",
		  "        std::vector<ll> parent;",
		  "        std::vector<ll> nums;",
		  "        ",
		  "        union_find(ll n) {",
		  "            parent.resize(n);",
		  "            nums.resize(n, 1LL);",
		  "            for(ll i = 0; i < n; i++) parent[i] = i;",
		  "        }",
		  "        ",
		  "        ll root(ll x) {",
		  "            if(parent[x] == x) return x;",
		  "            parent[x] = root(parent[x]);",
		  "            return parent[x];",
		  "        }",
		  "        ",
		  "        void unite(ll x, ll y) {",
		  "            ll rx = root(x);",
		  "            ll ry = root(y);",
		  "            if(rx != ry){",
		  "                parent[rx] = ry;",
		  "                nums[ry] += nums[rx];",
		  "            }",
		  "        }",
		  "        ",
		  "        bool same(ll x, ll y) {",
		  "            ll rx = root(x);",
		  "            ll ry = root(y);",
		  "            if(rx == ry) return true;",
		  "            return false;",
		  "        }",
		  "        ",
		  "        ll size(ll x) {",
		  "            return nums[root(x)];",
		  "        }",
		  "",
		  "    } uf;",
		  "",
		  "    typedef struct EdgeInfo {",
		  "        ll cost, u, v, id;",
		  "        EdgeInfo() {;};",
		  "        EdgeInfo(ll _cost, ll _u, ll _v, ll _id) : cost(_cost), u(_u), v(_v), id(_id) {};    ",
		  "        ~EdgeInfo() {;};",
		  "    } edge;",
		  "    bool operator<(const edge& t1, const edge& t2) { return (t1.cost < t2.cost); };",
		  "    bool operator>(const edge& t1, const edge& t2) { return (t1.cost > t2.cost); };",
		  "    bool operator<=(const edge& t1, const edge& t2) { return (t1.cost <= t2.cost); };",
		  "    bool operator>=(const edge& t1, const edge& t2) { return (t1.cost >= t2.cost); };",
		  "",
		  "    typedef struct krus {",
		  "",
		  "        ll N, M; // N: #nodes, M: #edges",
		  "        std::vector<edge> E;",
		  "        std::vector<ll> used_edges;",
		  "        ll cost;",
		  "",
		  "        krus(ll _N) : N(_N), cost(-1) {;}",
		  "",
		  "        void add(ll cost, ll u, ll v, ll id) {",
		  "            E.push_back(edge(cost, u, v, id));",
		  "        }",
		  "",
		  "        void add(ll cost, ll u, ll v) {",
		  "            ll id = E.size();",
		  "            E.push_back(edge(cost, u, v, id));",
		  "        }",
		  "",
		  "        ll build() {",
		  "            uf t(N);",
		  "            cost = 0;",
		  "            used_edges.clear();",
		  "            std::sort(E.begin(), E.end());",
		  "",
		  "            for(auto e : E) {",
		  "                if(!t.same(e.u, e.v)) {",
		  "                    t.unite(e.u, e.v);",
		  "                    cost += e.cost;",
		  "                    used_edges.push_back(e.id);",
		  "                }",
		  "            }",
		  "",
		  "            return cost;",
		  "        }",
		  "",
		  "        ll get_cost() {",
		  "            if(cost == -1) build();",
		  "            return cost;",
		  "        }",
		  "",
		  "        edge get_edge(ll i) {",
		  "            return E[i];",
		  "        }",
		  "",
		  "        std::vector<ll> get_used_edges() {",
		  "            if(cost == -1) build();",
		  "            return used_edges;",
		  "        }",
		  "",
		  "    } krus;",
		  "}",
		  "/*---------------ここまで---------------*/"
		],
		"description": ""
	  },
	  "dijkstra_function": {
		"prefix": "dijkstra_function",
		"body": [
		  "/*",
		  "Arguments:",
		  "- G   : 隣接リスト {destination edge, cost}",
		  "- d   : srtからの距離 <- これを変更する",
		  "- srt : 始点",
		  "*/",
		  "",
		  "void dijkstra(vector<vector<pair<ll,ll>>> G, vector<ll> &d, ll srt){",
		  "    priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>>> que;",
		  "    que.push({0, srt});",
		  "    d[srt] = 0;",
		  "    while(!que.empty()){",
		  "        auto q = que.top();",
		  "        que.pop();",
		  "        if(q.first > d[q.second]) continue;",
		  "        for(auto g : G[q.second]){",
		  "            if(d[g.first] <= q.first + g.second) continue;",
		  "            d[g.first] = q.first + g.second;",
		  "            que.push({d[g.first], g.first});",
		  "        }",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "runlength": {
		"prefix": "runlength",
		"body": [
		  "// ランレングス圧縮 string用",
		  "vector<pair<char,ll>> run_length_encoding(string s){",
		  "    vector<pair<char,ll>> res;",
		  "    ll n = s.size();",
		  "    char prev = -1;",
		  "    ll cur = 1;",
		  "    for(ll i = 0; i < n; i++) {",
		  "        if(prev == s[i]) cur++;",
		  "        else {",
		  "            if(prev != -1) res.push_back({prev, cur});",
		  "            prev = s[i];",
		  "            cur = 1;",
		  "        } ",
		  "    }",
		  "    res.push_back({prev, cur});",
		  "    return res;",
		  "}",
		  "// ランレングス圧縮 vector<ll>用",
		  "vector<pair<ll,ll>> run_length_encoding(vector<ll> s){",
		  "    vector<pair<ll,ll>> res;",
		  "    ll n = s.size();",
		  "    ll prev = -1;",
		  "    ll cur = 1;",
		  "    for(ll i = 0; i < n; i++) {",
		  "        if(prev == s[i]) cur++;",
		  "        else {",
		  "            if(prev != -1) res.push_back({prev, cur});",
		  "            prev = s[i];",
		  "            cur = 1;",
		  "        } ",
		  "    }",
		  "    res.push_back({prev, cur});",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "dump_snippets": {
		"prefix": "dump_snippets",
		"body": [
		  "// For debug",
		  "// Ref: https://qiita.com/ysuzuki19/items/d89057d65284ba1a16ac",
		  "#define dump(var)  do{std::cerr << #var << \" : \";view(var);}while(0)",
		  "template<typename T> void view(T e){std::cerr << e << \"\\n\";}",
		  "template<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cerr << e << \" \"; } std::cerr << \"\\n\";}",
		  "template<typename T> void view(const std::vector<std::vector<T> >& vv){ std::cerr << \"\\n\"; for(const auto& v : vv){ view(v); } }",
		  "template<typename T> void dump_cout(const T& v) { for(long long i = 0; i < v.size(); i++) std::cout << v[i] << (i == v.size()-1 ? \"\\n\" : \" \"); }"
		],
		"description": ""
	  },
	  "set grep2vec": {
		"prefix": "set_grep",
		"body": [
		  "/*",
		  "Function:",
		  "    - insert `num` elements from `st.begin()` into vector and return it/",
		  "Requirement:",
		  "    - num <= st.size()",
		  "    - if num > st.size(), print error message and return vector contains all of `st` elements.",
		  "*/",
		  "template<typename T> vector<T> grep2vec(set<T> &st, ll num){",
		  "    if(num > st.size()) {",
		  "        cerr << \"WARNIG [grep2vec] : Too large `num` for `st.size()`. \" << endl;",
		  "    }",
		  "    vector<T> res;",
		  "    auto itr = st.begin(); ",
		  "    for(ll i = 0; i < min(num, (ll)st.size()); i++) {",
		  "        res.push_back(*itr);",
		  "        itr++;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "/*",
		  "Function:",
		  "    - insert `num` elements from `st.rbegin()` into vector and return it/",
		  "Requirement:",
		  "    - num <= st.size()",
		  "    - if num > st.size(), print error message and return vector contains all of `st` elements.",
		  "*/",
		  "template<typename T> vector<T> rgrep2vec(set<T> &st, ll num){",
		  "    if(num > st.size()) {",
		  "        cerr << \"WARNIG [rgrep2vec] : Too large `num` for `st.size()`. \" << endl;",
		  "    }",
		  "    vector<T> res;",
		  "    auto itr = st.rbegin(); ",
		  "    for(ll i = 0; i < min(num, (ll)st.size()); i++) {",
		  "        res.push_back(*itr);",
		  "        itr++;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "str2dec": {
		"prefix": "str2dec",
		"body": [
		  "/*",
		  "オーバーフローには気を付けよう！",
		  "Inputs:",
		  "    string s : string representing a decimal number, such as 123.4, 0.123, 123.",
		  "    logn long shift_size : shift size, formally, this function return s * 10 ^ shift_size.",
		  "Output:",
		  "    Return s * 10 ^ shift_size as long long.",
		  "*/",
		  "long long str2dec(string s, long long shift_size) {",
		  "    auto pos = s.find('.');",
		  "    if(pos == string::npos) return atoll(s.c_str()) * pow(10LL, shift_size); // If s is an integer",
		  "    long long res = atoll(s.substr(0, pos).c_str()) * pow(10LL, shift_size); ",
		  "    res += atoll(s.substr(pos+1, s.size()-pos-1).c_str()) * pow(10LL, shift_size - (s.size()-pos-1));",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "split": {
		"prefix": "split",
		"body": [
		  "// python でいうところの s.split(c)",
		  "vector<string> split(string s, char c){",
		  "    vector<string> res;",
		  "    s.push_back(c); // 番兵",
		  "    ll n = s.size();",
		  "    string cur;",
		  "    for(ll i = 0; i < n; i++) {",
		  "        if(s[i] == c) {",
		  "            res.push_back(cur);",
		  "            cur = \"\";",
		  "        } else {",
		  "            cur.push_back(s[i]);",
		  "        }",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  }, 
	  "osa_k": {
		"prefix": "osa_k",
		"body": [
		  "/* --------- ここから --------- */",
		  "struct osa_k {",
		  "    using _ll = long long;",
		  "",
		  "    #define PRIME_FACTORIZE_MAX 2000010",
		  "    vector<_ll> primes;",
		  "",
		  "    osa_k() {",
		  "        primes.resize((PRIME_FACTORIZE_MAX));",
		  "        for(_ll i = 0; i < PRIME_FACTORIZE_MAX; i++) {",
		  "            primes[i] = 1;",
		  "        }",
		  "        for(_ll i = 2; i < PRIME_FACTORIZE_MAX; i++) {",
		  "            if(primes[i] != 1) continue;",
		  "            for(_ll j = i; j <= PRIME_FACTORIZE_MAX; j += i) {",
		  "                primes[j] = i;",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    vector<pair<_ll,_ll>> factorize(_ll n){",
		  "        vector<pair<_ll,_ll>> res;",
		  "        while(n != 1) {",
		  "            _ll cur = primes[n];",
		  "            _ll cnt = 0;",
		  "            while(n % cur == 0) {",
		  "                n /= cur;",
		  "                cnt++;",
		  "            }",
		  "            res.push_back({cur, cnt});",
		  "        }",
		  "        reverse(res.begin(), res.end());",
		  "        return res;",
		  "    }",
		  "} osa_k;",
		  "",
		  "vector<pair<long long, long long>>factorize(long long n) {",
		  "    return osa_k.factorize(n);",
		  "}",
		  "/* --------- ここまで --------- */"
		],
		"description": ""
	  },
	  "gradient": {
		"prefix": "gradient_katamuki",
		"body": [
		  "ll gcd(ll a, ll b){",
		  "    if(a < b) return gcd(b, a);",
		  "    ll r = a % b;",
		  "    while(r != 0){",
		  "        a = b;",
		  "        b = r;",
		  "        r = a % b;",
		  "    }",
		  "    return b;",
		  "}",
		  "",
		  "ll lcm(ll a, ll b){",
		  "    ll ret = a / gcd(a,b) * b;",
		  "    return ret;",
		  "}",
		  "",
		  "pair<ll, ll> gradient(ll x1, ll y1, ll x2, ll y2) {",
		  "    ll dx = x2 - x1;",
		  "    ll dy = y2 - y1;",
		  "    if(dx < 0) {",
		  "        dx = -dx;",
		  "        dy = -dy;",
		  "    }",
		  "    if(dx == 0 && dy == 0) return {0, 0};",
		  "    else if(dx == 0) return {0, 1};",
		  "    else if(dy == 0) return {1, 0};",
		  "    ll g = gcd(abs(dx), abs(dy));",
		  "    dx /= g;",
		  "    dy /= g;",
		  "    return make_pair(dx, dy);",
		  "}"
		],
		"description": "2点の傾きを整数値で持つ"
	  },
	  "all same": {
		"prefix": "all_same",
		"body": [
		  "template<typename T> bool all_same(vector<T>& a) {",
		  "    if(a.empty()) return true;",
		  "    for(ll i = 0; i < a.size(); i++) if(a[i] != a[0]) return false;",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "dijkstra_grid_snippets": {
		"prefix": "dijkstra_grid_snippets",
		"body": [
		  "/*---------ここから---------*/",
		  "using _ll = long long;",
		  "using _pl = pair<_ll, _ll>;",
		  "using _tl = pair<_ll, _pl>;",
		  "void dijkstra(vector<vector<_ll>> &dist, vector<string> &maze, _pl initial_pos) {",
		  "    /* 遷移方向を変更したいときはここを変更する。*/",
		  "    const _ll dx[4] = {1, -1, 0, 0};",
		  "    const _ll dy[4] = {0, 0, 1, -1};",
		  "",
		  "    _ll H = maze.size();",
		  "    _ll W = maze[0].size();",
		  "    auto ng = [&](_ll i, _ll j) {",
		  "        return (i < 0 || j < 0 || i >= H || j >= W);",
		  "    };",
		  "",
		  "    priority_queue<_tl, vector<_tl>, greater<_tl>> que;",
		  "    que.push({0, initial_pos});",
		  "    dist[initial_pos.first][initial_pos.second] = 0;",
		  "",
		  "    while(!que.empty()) {",
		  "        auto q = que.top();",
		  "        que.pop();",
		  "        auto cur_cost = q.first;",
		  "        auto cur_i = q.second.first;",
		  "        auto cur_j = q.second.second;",
		  "        for(_ll k = 0; k < 4; k++) {",
		  "            auto next_i = cur_i + dx[k];",
		  "            auto next_j = cur_j + dy[k];",
		  "            if(ng(next_i, next_j)) continue;",
		  "",
		  "            /* コストを変更したいときはここを変更する。*/",
		  "            auto next_cost = cur_cost + 1;",
		  "",
		  "            if(dist[next_i][next_j] <= next_cost) continue;",
		  "",
		  "            /* 遷移条件を変更したいときはここを変更する。*/",
		  "            if(maze[next_i][next_j] == '#') continue;",
		  "",
		  "            dist[next_i][next_j] = next_cost;",
		  "            que.push({next_cost, {next_i, next_j}});",
		  "        }",
		  "    }",
		  "}",
		  "/*---------ここまで---------*/"
		],
		"description": ""
	  },
	  "dijkstra_list_snippet": {
		"prefix": "dijkstra_list_snippet",
		"body": [
		  "/*-------ここから--------*/",
		  "using _ll = long long;",
		  "using _pl = pair<_ll, _ll>;",
		  "void dijkstra(vector<vector<_pl>> &G, vector<_ll> &dist, _ll initial_pos) {",
		  "    priority_queue<_pl, vector<_pl>, greater<_pl>> que;",
		  "    dist[initial_pos] = 0;",
		  "    que.push({0, initial_pos});",
		  "    while(!que.empty()) {",
		  "        auto q = que.top();",
		  "        que.pop();",
		  "        auto cur_cost = q.first;",
		  "        auto cur_pos = q.second;",
		  "        for(auto e : G[cur_pos]) {",
		  "            auto next_pos = e.first;",
		  "            auto next_cost = cur_cost + e.second;",
		  "            if(next_cost >= dist[next_pos]) continue;",
		  "            dist[next_pos] = next_cost;",
		  "            que.push({next_cost, next_pos});",
		  "        }",
		  "    }",
		  "}",
		  "/*-------ここまで--------*/",
		  ""
		],
		"description": ""
	  },
	  "": {
		"prefix": "mod_utils_snippet",
		"body": [
		  "",
		  "/*---------------- I Love AtCoder Library ---------------------*/",
		  "#include <atcoder/modint>",
		  "// parameters",
		  "using mint = atcoder::modint1000000007;",
		  "#define MOD_UTILS_NMAX 1000100",
		  "",
		  "struct mod_utils {",
		  "    // data",
		  "    std::vector<mint> _fac, _inv;",
		  "    // construct & initialize",
		  "    mod_utils() { ",
		  "        _fac.resize(MOD_UTILS_NMAX);",
		  "        _inv.resize(MOD_UTILS_NMAX);",
		  "        _fac[0] = 1; _fac[1] = 1;",
		  "        _inv[0] = 1; _inv[1] = 1;",
		  "        for(int i = 2; i < MOD_UTILS_NMAX; i++) {",
		  "            _fac[i] = _fac[i-1] * mint(i);",
		  "            _inv[i] = _inv[i-1] * mint(i).inv();",
		  "        }",
		  "    }",
		  "} _mod_utils;",
		  "",
		  "// functions",
		  "mint fac(int i) { return _mod_utils._fac[i]; }",
		  "mint inv_fac(int i) { return _mod_utils._inv[i]; }",
		  "mint nck(int n, int k) { ",
		  "    if (n < k) return 0;",
		  "    if (n < 0 || k < 0) return 0;",
		  "    if(k == 0 || k == n) return 1;",
		  "    return _mod_utils._fac[n] * _mod_utils._inv[k] * _mod_utils._inv[n-k];",
		  "}"
		],
		"description": ""
	  },
	  "median": {
		"prefix": "median_manage",
		"body": [
		  "#include <atcoder/fenwicktree>",
		  "typedef struct _median_manage {",
		  "    // vaiables",
		  "    atcoder::fenwick_tree<int> fw;  ",
		  "    int nmax, real_size;",
		  "    // construct",
		  "    _median_manage(int _n) : nmax(_n), real_size(_n+10) {",
		  "        fw = atcoder::fenwick_tree<int>(real_size);",
		  "    }",
		  "    bool insert(int i) {",
		  "        if(fw.sum(i, i+1) == 1) return false;",
		  "        fw.add(i, 1);",
		  "        return true;",
		  "    }",
		  "    bool erase(int i) {",
		  "        if(fw.sum(i, i+1) == 0) return false;",
		  "        fw.add(i, -1);",
		  "        return true;",
		  "    }",
		  "    long long get_median() {",
		  "        int sum = fw.sum(0, real_size);",
		  "        assert(sum > 0);",
		  "        int l = -1, r = real_size;",
		  "        while(r - l > 1) {",
		  "            int m = (l + r) / 2;",
		  "            if(fw.sum(0, m+1) < (sum+1) / 2) l = m;",
		  "            else r = m; ",
		  "        }",
		  "        return r;",
		  "    }",
		  "    long long get_lnum() {",
		  "        int sum = fw.sum(0, real_size);",
		  "        if(sum == 0) return 0;",
		  "        return (sum+1) / 2 - 1;",
		  "    }",
		  "    long long get_rnum() {",
		  "        int sum = fw.sum(0, real_size);",
		  "        return sum / 2;",
		  "    }",
		  "    long long get_sum() {",
		  "        return fw.sum(0, real_size);",
		  "    }",
		  "} medi;"
		],
		"description": ""
	  },
	  "lca": {
		"prefix": "lca_snippet",
		"body": [
		  "namespace lca {",
		  "    /* Reference: https://algo-logic.info/lca/ */",
		  "",
		  "    using _ll = long long;",
		  "    typedef _ll edge;",
		  "",
		  "    typedef struct lca {",
		  "        std::vector<std::vector<_ll>> parent;",
		  "        std::vector<_ll> dist;",
		  "",
		  "        void dfs(std::vector<std::vector<edge>> &G, _ll cur, _ll par, _ll d) {",
		  "            dist[cur] = d;",
		  "            parent[0][cur] = par;",
		  "            for(auto e : G[cur]) if(e != par) dfs(G, e, cur, d+1);",
		  "        }",
		  "",
		  "        lca(std::vector<std::vector<edge>> &G, _ll root = 0) {",
		  "            _ll n = G.size();",
		  "            _ll k = 1;",
		  "            while((1LL<<k) < n) k++;",
		  "            parent.resize(k+1, std::vector<_ll>(n, -1));",
		  "            dist.resize(n, -1);",
		  "            dfs(G, root, -1, 0);",
		  "            for(_ll i = 0; i < k; i++) {",
		  "                for(_ll j = 0; j < n; j++) {",
		  "                    if(parent[i][j] == -1) parent[i+1][j] = -1;",
		  "                    else parent[i+1][j] = parent[i][parent[i][j]];",
		  "                }",
		  "            }",
		  "        }",
		  "",
		  "        _ll get_lca(_ll u, _ll v) {",
		  "            if(dist[u] < dist[v]) std::swap(u, v);",
		  "            _ll sz = parent.size();",
		  "            for(_ll i = 0; i < sz; i++) {",
		  "                _ll d = dist[u] - dist[v];",
		  "                if((d >> i) & 1LL) u = parent[i][u];",
		  "            }",
		  "            if(u == v) return u;",
		  "            for(_ll i = sz-1; i >= 0; i--) {",
		  "                if(parent[i][u] != parent[i][v]) {",
		  "                    u = parent[i][u];",
		  "                    v = parent[i][v];",
		  "                }",
		  "            }",
		  "            return parent[0][u];",
		  "        }",
		  "",
		  "        _ll get_dist(_ll u, _ll v) {",
		  "            return dist[u] + dist[v] - 2 * dist[get_lca(u, v)];",
		  "        }",
		  "",
		  "        /* If there is the node \"a\" on the path from u to v */",
		  "        bool is_on_path(_ll u, _ll v, _ll a) {",
		  "            return (get_dist(u, a) == get_dist(v, a));",
		  "        }",
		  "    } lca;",
		  "}"
		],
		"description": ""
	  },
	  "LIS": {
		"prefix": "lis_snippet",
		"body": [
		  "// けんちょんさんの",
		  "ll lis(vector<ll> &a) {",
		  "    constexpr ll inf = 1e18+13;",
		  "    ll n = a.size();",
		  "    vector<ll> dp(n, inf);",
		  "    for(ll i = 0; i < n; i++) {",
		  "        auto itr = lower_bound(dp.begin(), dp.end(), a[i]);",
		  "        *itr = a[i];",
		  "    }",
		  "    return lower_bound(dp.begin(), dp.end(), inf) - dp.begin();",
		  "}"
		],
		"description": ""
	  },
	  "atcoder_dsu": {
		"prefix": "atcoder_dsu",
		"body": [
		  "/*---------- I love AtCoder Library ---------*/",
		  "#include <atcoder/dsu>",
		  "using namespace atcoder;",
		  ""
		],
		"description": ""
	  },
	  "atcoder_bit": {
		"prefix": "atcoder_bit",
		"body": [
		  "/*---------- I love AtCoder Library ---------*/",
		  "#include <atcoder/fenwicktree>",
		  "using namespace atcoder;",
		  "template<typename T> void view(fenwick_tree<T>& bit, ll n) {",
		  "    rep(i, 0, n) cerr << bit.sum(i, i+1) << (i == n-1 ? \"\\n\" : \" \");",
		  "}",
		  "template<typename T> ll ith_element(fenwick_tree<T>&bit, ll ith, ll n) {",
		  "    ll le = 0, ri = n+1;",
		  "    while(ri - le > 1) {",
		  "        auto mi = (le + ri) / 2;",
		  "        auto tmp = bit.sum(0, mi);",
		  "        if(tmp < ith) le = mi;",
		  "        else ri = mi;",
		  "    }",
		  "    return ri-1;",
		  "}"
		],
		"description": ""
	  },
	  "atcoder_modint": {
		"prefix": "atcoder_modint",
		"body": [
		  "/*---------- I love AtCoder Library ---------*/",
		  "#include <atcoder/modint>",
		  "using namespace atcoder;",
		  "using mint = modint1000000007;",
		  "//using mint = modint998244353;"
		],
		"description": ""
	  },
	  "bubble_sort_count_snippets": {
		"prefix": "bubble_sort_count_snippets",
		"body": [
		  "/*---------- I love AtCoder Library ---------*/",
		  "#include <atcoder/fenwicktree>",
		  "using namespace atcoder;",
		  "",
		  "//https://misteer.hatenablog.com/entry/ARC088-E",
		  "ll bubble_count(string from, string to) {",
		  "    assert(from.size() == to.size());",
		  "    ll n = from.size();",
		  "    vector<queue<ll>> que(26);",
		  "    rep(i, 0, n) que[from[i]-'a'].push(i);",
		  "    vector<ll> idx(n);",
		  "    rep(i, 0, n) {",
		  "        idx[i] = que[to[i]-'a'].front();",
		  "        que[to[i]-'a'].pop();",
		  "    }",
		  "    fenwick_tree<ll> t(n+1);",
		  "    ll res = 0;",
		  "    rep(i, 0, n) {",
		  "        res += t.sum(idx[i], n);",
		  "        t.add(idx[i], 1);",
		  "    }",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "string_add": {
		"prefix": "string_add",
		"body": [
		  "string add(string a, string b) {",
		  "    reverse(a.begin(), a.end());",
		  "    reverse(b.begin(), b.end());",
		  "    ll n = max(a.size(), b.size());",
		  "    while(a.size() < n) a.push_back('0');",
		  "    while(b.size() < n) b.push_back('0');",
		  "    string res;",
		  "    ll age = 0;",
		  "    rep(i, 0, n) {",
		  "        ll cur = age + (a[i] - '0') + (b[i] - '0');",
		  "        res.push_back(cur % 10 + '0');",
		  "        age = cur / 10;",
		  "    }",
		  "    if(age) res.push_back('1');",
		  "    reverse(res.begin(), res.end());",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "tree_diameter_snippets": {
		"prefix": "tree_diameter_snippets",
		"body": [
		  "// first: distance, second: node id",
		  "pair<ll,ll> farthest_node(vector<vector<ll>>& G, ll cur, ll par) {",
		  "    ll res = 0, id = cur;",
		  "    for(auto e : G[cur]) {",
		  "        if(e == par) continue;",
		  "        auto t = farthest_node(G, e, cur);",
		  "        if(res < t.first + 1) {",
		  "            res = t.first + 1;",
		  "            id = t.second;",
		  "        }",
		  "    }",
		  "    return {res, id};",
		  "}",
		  "",
		  "pair<ll,ll> farthest_node(vector<vector<pair<ll,ll>>>& G, ll cur, ll par) {",
		  "    ll res = 0, id = cur;",
		  "    for(auto e : G[cur]) {",
		  "        if(e.first == par) continue;",
		  "        auto t = farthest_node(G, e.first, cur);",
		  "        if(res < t.first + e.second) {",
		  "            res = t.first + e.second;",
		  "            id = t.second;",
		  "        }",
		  "    }",
		  "    return {res, id};",
		  "}",
		  "",
		  "ll tree_diameter(vector<vector<ll>>& G) {",
		  "    auto x = farthest_node(G, 0, -1);",
		  "    auto y = farthest_node(G, x.second, -1);",
		  "    return y.first;",
		  "}",
		  "",
		  "ll tree_diameter(vector<vector<pair<ll,ll>>>& G) {",
		  "    auto x = farthest_node(G, 0, -1);",
		  "    auto y = farthest_node(G, x.second, -1);",
		  "    return y.first;",
		  "}"
		],
		"description": ""
	  },
	  "pow_snippets": {
		"prefix": "pow_snippets",
		"body": [
		  "ll pow(ll a, ll p) {",
		  "    ll res = 1;",
		  "    rep(i, 0, p) res *= a;",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "saisyo_hougan_en_min_ball_minball": {
		"prefix": "saisyo_hougan_en_min_ball_minball",
		"body": [
		  "",
		  "// https://tubo28.me/compprog/algorithm/minball/",
		  "",
		  "using ld = double;",
		  "using P = complex<ld>;",
		  "using G = vector<P>;",
		  "const ld pi = acos(-1);",
		  "const ld eps = 1e-10;",
		  "const ld inf = 1e12;",
		  "",
		  "ld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }",
		  "ld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }",
		  "",
		  "template <class iter>",
		  "std::pair<P, ld> min_ball(iter left, iter right, int seed = 1333) {",
		  "    const int n = right - left;",
		  "",
		  "    assert(n >= 1);",
		  "    if (n == 1) {",
		  "        return {*left, ld(0)};",
		  "    }",
		  "",
		  "    std::mt19937 mt(seed);",
		  "    std::shuffle(left, right, mt);",
		  "    // std::random_shuffle(left, right); // simple but deprecated",
		  "",
		  "    iter ps = left;",
		  "    using circle = std::pair<P, ld>;",
		  "",
		  "    auto make_circle_3 = [](const P &a, const P &b, const P &c) -> circle {",
		  "        ld A = std::norm(b - c), B = std::norm(c - a), C = std::norm(a - b),",
		  "           S = cross(b - a, c - a);",
		  "        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);",
		  "        ld r2 = std::norm(p - a);",
		  "        return {p, r2};",
		  "    };",
		  "",
		  "    auto make_circle_2 = [](const P &a, const P &b) -> circle {",
		  "        P c = (a + b) / (ld)2;",
		  "        ld r2 = std::norm(a - c);",
		  "        return {c, r2};",
		  "    };",
		  "",
		  "    auto in_circle = [](const P &a, const circle &c) -> bool {",
		  "        return std::norm(a - c.first) <= c.second + eps;",
		  "    };",
		  "",
		  "    circle c = make_circle_2(ps[0], ps[1]);",
		  "",
		  "    // MiniDisc",
		  "    for (int i = 2; i < n; ++i) {",
		  "        if (!in_circle(ps[i], c)) {",
		  "            // MiniDiscWithPoint",
		  "            c = make_circle_2(ps[0], ps[i]);",
		  "            for (int j = 1; j < i; ++j) {",
		  "                if (!in_circle(ps[j], c)) {",
		  "                    // MiniDiscWith2Points",
		  "                    c = make_circle_2(ps[i], ps[j]);",
		  "                    for (int k = 0; k < j; ++k) {",
		  "                        if (!in_circle(ps[k], c)) {",
		  "                            c = make_circle_3(ps[i], ps[j], ps[k]);",
		  "                        }",
		  "                    }",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "    return c;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "string_sub": {
		"prefix": "string_sub",
		"body": [
		  "string sub(string a, string b) {",
		  "    ll n = max(a.size(), b.size());",
		  "    assert(a.size() > b.size() || a >= b);",
		  "    reverse(a.begin(), a.end());",
		  "    reverse(b.begin(), b.end());",
		  "    while(a.size() < n) a.push_back('0');",
		  "    while(b.size() < n) b.push_back('0');",
		  "    string res;",
		  "    ll age = 0;",
		  "    rep(i, 0, n) {",
		  "        if(a[i] < '0' || a[i] < b[i]) {",
		  "            assert(i != n-1);",
		  "            a[i] += 10;",
		  "            a[i+1] -= 1;",
		  "        }",
		  "        ll cur = (a[i] - b[i]) + '0';",
		  "        res.push_back(cur);",
		  "    }",
		  "    while(!res.empty()) {",
		  "        if(res.back() == '0') res.pop_back();",
		  "        else break;",
		  "    }",
		  "    if(res.empty()) res.push_back('0');",
		  "    reverse(res.begin(), res.end());",
		  "    return res;",
		  "}"
		],
		"description": ""
	},
	"nijigen_2jigen_ruisekiwa_acc": {
		"prefix": "nijigen_2jigen_ruisekiwa_acc",
		"body": [
		  "// https://ei1333.github.io/algorithm/cumulative-sum2d.html",
		  "// sx, sy を含み，gx, gy を含まない",
		  "template< class T >",
		  "struct CumulativeSum2D",
		  "{",
		  "  vector< vector< T > > data;",
		  "",
		  "  CumulativeSum2D(int W, int H) : data(W + 1, vector< T >(H + 1, 0)) {}",
		  "",
		  "  void add(int x, int y, T z)",
		  "  {",
		  "    ++x, ++y;",
		  "    if(x >= data.size() || y >= data[0].size()) return;",
		  "    data[x][y] += z;",
		  "  }",
		  "",
		  "  void build()",
		  "  {",
		  "    for(int i = 1; i < data.size(); i++) {",
		  "      for(int j = 1; j < data[i].size(); j++) {",
		  "        data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];",
		  "      }",
		  "    }",
		  "  }",
		  "",
		  "  T query(int sx, int sy, int gx, int gy)",
		  "  {",
		  "    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);",
		  "  }",
		  "};",
		  ""
		],
		"description": ""
	  }
}
