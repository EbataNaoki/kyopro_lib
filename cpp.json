{
	"cin_vector_int":{
        "prefix": "cvi",
        "body":[
            "vector<int> $1($2);",
            "rep(i, $2, $3) cin >> $1[i];",
            "$3"
        ],
        "description": "vector<int>の受取"
	},
	
	"gcdlcm": {
		"prefix": "gcdlcm",
		"body": [
		  "ll gcd(ll a, ll b){",
		  "    if(a < b) return gcd(b, a);",
		  "    ll r = a % b;",
		  "    while(r != 0){",
		  "        a = b;",
		  "        b = r;",
		  "        r = a % b;",
		  "    }",
		  "    return b;",
		  "}",
		  "",
		  "ll lcm(ll a, ll b){",
		  "    ll ret = a / gcd(a,b) * b;",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },

	"is_prime": {
		"prefix": "isprime",
		"body": [
		  "bool is_prime(ll a){",
		  "    if(a == 1) return false;",
		  "    for(ll i=2; i*i<=a; i++){",
		  "        if(a%i == 0) return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": "identifying prime number of not"
	  },

	  "factorize": {
		"prefix": "factorize",
		"body": [
		  "vector<ll> factorize(ll g){",
		  "    if(g == 1){",
		  "        return {};",
		  "    }",
		  "    ll d = 2;",
		  "    vector<ll> ret;",
		  "    while(d*d <= g){",
		  "        if(g % d == 0){",
		  "            g /= d;",
		  "            while(g % d == 0){",
		  "                g /= d;",
		  "            }",
		  "            ret.push_back(d);",
		  "        }",
		  "        d++;",
		  "    }",
		  "    if(g != 1) ret.push_back(g);",
		  "    return ret;",
		  "}"
		],
		"description": "factorize"
	  },

	  "keta_sum": {
		"prefix": "ketasum",
		"body": [
		  "ll keta_sum(ll a){",
		  "    ll ret = 0;",
		  "    while(a > 0){",
		  "        ret += a%10;",
		  "        a /= 10;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "sum of digits"
	  },

	  "keta_bunkai": {
		"prefix": "ketabunkai",
		"body": [
		  "vector<ll> keta_bunkai(ll a){",
		  "    string s = to_string(a);",
		  "    vector<ll> ret;",
		  "    for(auto p : s){",
		  "        ret.push_back((ll)(p - '0'));",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "keta bunkai"
	  },

	  "distance": {
		"prefix": "dist",
		"body": [
		  "template<typename T> T dist(T x0, T y0, T x, T y){",
		  "    T ret = sqrt((x-x0)*(x-x0) + (y-y0)*(y-y0));",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": "distance between two grid point"
	  },
	  
	  "normal_nck": {
		"prefix": "normal_nck",
		"body": [
		  "ll gcd(ll a, ll b){",
		  "    if(a < b) return gcd(b, a);",
		  "    ll r = a % b;",
		  "    while(r != 0){",
		  "        a = b;",
		  "        b = r;",
		  "        r = a % b;",
		  "    }",
		  "    return b;",
		  "}",
		  "",
		  "ll nck(ll n, ll k){",
		  "  if (n < k) return 0;",
		  "  if (n < 0 || k < 0) return 0;",
		  "  if(k == 0 || k == n) return 1;",
		  "  ll nume = 1, deno = 1;",
		  "  for(int i=0; i<k; i++){",
		  "    nume *= (n-i);",
		  "    deno *= (i+1);",
		  "    ll g = gcd(nume, deno);",
		  "    nume /= g;",
		  "    deno /= g;",
		  "  }",
		  "  return (ll)(nume/deno);",
		  "}",
		  ""
		],
		"description": ""
	  },

	  "nck_mod_p": {
		"prefix": "kenchon_nck",
		"body": [
		  "const int MAX = 510000;",
		  "const int MOD = 1000000007;",
		  "",
		  "long long fac[MAX], finv[MAX], inv[MAX];",
		  "",
		  "// テーブルを作る前処理",
		  "void COMinit() {",
		  "    fac[0] = fac[1] = 1;",
		  "    finv[0] = finv[1] = 1;",
		  "    inv[1] = 1;",
		  "    for (int i = 2; i < MAX; i++){",
		  "        fac[i] = fac[i - 1] * i % MOD;",
		  "        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
		  "        finv[i] = finv[i - 1] * inv[i] % MOD;",
		  "    }",
		  "}",
		  "",
		  "// 二項係数計算",
		  "long long COM(int n, int k){",
		  "    if (n < k) return 0;",
		  "    if (n < 0 || k < 0) return 0;",
		  "    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
		  "}",
		  ""
		],
		"description": "mod nck"
	  },

	  "nck_mod": {
		"prefix": "nck_mod",
		"body": [
		  "ll mod = 1e9+7;",
		  "#define NMAX 200010",
		  "ll fac[NMAX];",
		  "ll inv[NMAX];",
		  "",
		  "ll mod_pow(ll a, ll n, ll mod){",
		  "    ll ret = 1;",
		  "    while(n > 0){",
		  "        if(n & 1) ret = (ret*(a % mod))%mod;",
		  "        a = ((a%mod)*(a%mod)) % mod;",
		  "        n = n >> 1;",
		  "    }",
		  "    return ret;",
		  "}",
		  "",
		  "ll mod_inv(ll a, ll mod){",
		  "    return mod_pow(a, mod-2, mod);",
		  "}",
		  "",
		  "void mae_nck(){",
		  "    fac[1] = 1;",
		  "    inv[1] = 1;",
		  "    for(ll i = 2; i < NMAX; i++){",
		  "        fac[i] = (fac[i-1] * i)%mod;",
		  "        inv[i] = (inv[i-1] * mod_inv(i, mod))%mod;",
		  "    }",
		  "}",
		  "",
		  "ll mod_nck(ll n, ll k){",
		  "    if (n < k) return 0;",
		  "    if (n < 0 || k < 0) return 0;",
		  "    if(k == 0 || k == n) return 1;",
		  "    ll ret = ((fac[n] * inv[k])%mod * inv[n-k])%mod;",
		  "    return ret;",
		  "}"
		],
		"description": "nck mod p"
	  },

	  "unioon find": {
		"prefix": "unionfind",
		"body": [
		  "struct union_find{",
		  "    vector<ll> parent;",
		  "    vector<ll> nums;",
		  "    union_find(ll n){",
		  "        parent.resize(n);",
		  "        nums.resize(n, 1LL);",
		  "        rep(i, 0, n) parent[i] = i;",
		  "    }",
		  "",
		  "    ll root(ll x){",
		  "        if(parent[x] == x) return x;",
		  "        parent[x] = root(parent[x]);",
		  "        return parent[x];",
		  "    }",
		  "",
		  "    void unite(ll x, ll y){",
		  "        ll rx = root(x);",
		  "        ll ry = root(y);",
		  "        if(rx != ry){",
		  "            parent[rx] = ry;",
		  "            nums[ry] += nums[rx];",
		  "        }",
		  "    }",
		  "",
		  "    bool same(ll x, ll y){",
		  "        ll rx = root(x);",
		  "        ll ry = root(y);",
		  "        if(rx == ry) return true;",
		  "        return false;",
		  "    }",
		  "",
		  "    ll size(ll x){",
		  "        return nums[root(x)];",
		  "    }",
		  "};  "
		],
		"description": ""
	  },

	  "map_factorize": {
		"prefix": "map_factorize",
		"body": [
		  "map<ll, ll> factorize(ll g){",
		  "    map<ll, ll> ret;",
		  "    if(g == 1){",
		  "        ret[1]++;",
		  "        return ret;",
		  "    }",
		  "    ll d = 2;",
		  "    while(d*d <= g){",
		  "        if(g % d == 0){",
		  "            ret[d]++;",
		  "            g /= d;",
		  "            while(g % d == 0){",
		  "                ret[d]++;",
		  "                g /= d;",
		  "            }",
		  "        }",
		  "        d++;",
		  "    }",
		  "    if(g != 1) ret[g]++;",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "dist": {
		"prefix": "dist_line_point",
		"body": [
		  "double dist(double x1, double y1, double x2, double y2, double p, double q){",
		  "    double a = y2 - y1;",
		  "    double b = x2 - x1;",
		  "    double c = -x1*a + y1*b;",
		  "    double d = abs(a*p - b*q + c)/sqrt(a*a+b*b);",
		  "    return d;",
		  "}"
		],
		"description": "Calcurate the distance between a line and a point. The line is expressed by two points that are on the line."
	  },
	  "min_dga": {
		"prefix": "min_dag",
		"body": [
		  "/*",
		  "使い方",
		  "1. 以下をグローバル宣言",
		  "- ワーシャルフロイド用の2点間距離配列 d",
		  "- グラフ G",
		  "- 最短経路のみを持つDAG DAG",
		  "",
		  "2. dとGを初期化",
		  "- NOTE： 1-indexed",
		  "",
		  "3. make_dag(始点，終点，頂点数);",
		  "",
		  "たぶん O(N^3)",
		  "*/",
		  "",
		  "vector<vector<ll>> DAG, d, G;",
		  "",
		  "void make_dag(ll A, ll B, ll N){",
		  "    ",
		  "    //　ワーシャルフロイド",
		  "    rep(i, 1, N+1) d[i][i] = 0;",
		  "    rep(i, 1, N+1){",
		  "        rep(j, 1, N+1){",
		  "            rep(k, 1, N+1){",
		  "                d[j][k] = min(d[j][k], d[j][i] + d[i][k]);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    // 最短経路のみのDAG作成",
		  "    DAG.resize(N+1);",
		  "    queue<ll> que;",
		  "    vector<bool> seen(N+1, false);",
		  "    que.push(A);",
		  "    while(!que.empty()){",
		  "        auto t = que.front();",
		  "        que.pop();",
		  "        if(seen[t]) continue;",
		  "        seen[t] = true;",
		  "        for(auto g : G[t]){",
		  "            if(d[A][t] + 1 + d[g][B] == d[A][B]){",
		  "                DAG[t].push_back(g);",
		  "                que.push(g);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "warshall": {
		"prefix": "warshall",
		"body": [
		  "rep(i, 1, N+1) d[i][i] = 0;",
		  "rep(i, 1, N+1){",
		  "    rep(j, 1, N+1){",
		  "        rep(k, 1, N+1){",
		  "            d[j][k] = min(d[j][k], d[j][i] + d[i][k]);",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "warshall-floyd"
	  },
	  "plus_templates": {
		"prefix": "plustemplate",
		"body": [
		  "#define VL vector<ll>",
		  "#define VS vector<string>",
		  "#define VB vector<bool>",
		  "#define VP vector<pair<ll,ll>>",
		  "#define VVL vector<vector<ll>>",
		  "#define VVP vector<vector<pair<ll,ll>>>",
		  "#define PL pair<ll,ll>",
		  "#define ALL(v) (v).begin(), (v).end()",
		  "ll d1[4] = {1, -1, 0, 0};",
		  "ll d2[4] = {0, 0, 1, -1};"
		],
		"description": ""
	  },
	  "yakusu": {
		"prefix": "yakusu",
		"body": [
		  "vector<ll> yakusu(ll n){",
		  "    vector<ll> ret;",
		  "    for(ll i = 1; i*i <= n; i++){",
		  "        if(n % i != 0) continue;",
		  "        ret.push_back(i);",
		  "        if(i*i != n) ret.push_back(n/i);",
		  "    }",
		  "    sort(ret.begin(), ret.end());",
		  "    return ret;",
		  "}"
		],
		"description": "all of yakusu"
	  },
	  "dijkstra": {
		"prefix": "dijkstra",
		"body": [
		  "/*",
		  "    ll N, M; cin >> N >> M;",
		  "    vector<vector<pair<ll,ll>>> G(N+1);",
		  "    rep(i, 0, M){",
		  "        ll v, u, w;",
		  "        cin >> v >> u >> w;",
		  "        G[u].push_back({v, w});",
		  "        G[v].push_back({u, w});",
		  "    }",
		  "",
		  "    ll srt = 1;",
		  "    vector<ll> d(N+1, 1e18);",
		  "    */",
		  "   ",
		  "    /* dijkstra's scope */{",
		  "        priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>>> que;",
		  "        que.push({0, srt});",
		  "        d[srt] = 0;",
		  "        while(!que.empty()){",
		  "            auto q = que.top();",
		  "            que.pop();",
		  "            if(q.first > d[q.second]) continue;",
		  "            for(auto g : G[q.second]){",
		  "                if(d[g.first] <= q.first + g.second) continue;",
		  "                d[g.first] = q.first + g.second;",
		  "                que.push({d[g.first], g.first});",
		  "            }",
		  "        }",
		  "    }"
		],
		"description": "dijkstra"
	  },
	  "prime factorize": {
		"prefix": "prime_factorize",
		"body": [
		  "vector<pair<ll,ll>> prime_factorize(ll N){",
		  "    vector<pair<ll,ll>> ret;",
		  "    for(ll a = 2; a * a <= N; a++){",
		  "        if(N % a != 0) continue;",
		  "        ll ex = 0;",
		  "        while(N % a == 0){",
		  "            ex++;",
		  "            N /= a;",
		  "        }",
		  "        ret.push_back({a, ex});",
		  "    }",
		  "    if(N != 1) ret.push_back({N, 1});",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },
	  "Z-algorithm": {
		"prefix": "Zalgo",
		"body": [
		  "vector<ll> Zalgo(string S){",
		  "    ll N = S.size();",
		  "    vector<ll> ret(N);",
		  "    ret[0] = N;",
		  "    ll i = 1, j = 0;",
		  "    while(i < N){",
		  "        while(i + j < N && S[j] == S[i+j]) j++;",
		  "        ret[i] = j;",
		  "        if(j == 0){",
		  "            i++;",
		  "            continue;",
		  "        }",
		  "        ll k = 1;",
		  "        while(i + k < N && k + ret[k] < j){",
		  "            ret[i+k] = ret[k];",
		  "            k++;",
		  "        }",
		  "        i += k;",
		  "        j -= k;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": ""
	  },
	  "PI": {
		"prefix": "PI",
		"body": [
		  "constexpr double PI=3.14159265358979323846;"
		],
		"description": ""
	  },
	  "fenwick tree": {
		"prefix": "BIT",
		"body": [
		  "#define FENWICK_NMAX 200010",
		  "struct fenwick_tree{",
		  "    ll N;",
		  "    ll bit[FENWICK_NMAX];",
		  "    fenwick_tree(ll n){",
		  "        N = n;",
		  "        for(ll x = 1; x <= N; x++){",
		  "            bit[x] = 0;",
		  "        }",
		  "    }",
		  "    void add(ll a, ll w){",
		  "        for(ll x = a; x <= N; x += x & -x){",
		  "            bit[x] += w;",
		  "        }",
		  "    }",
		  "    ll sum(ll a){",
		  "        ll ret = 0;",
		  "        for(ll x = a; x > 0; x -= x & -x){",
		  "            ret += bit[x];",
		  "        }",
		  "        return ret;",
		  "    }",
		  "};"
		],
		"description": "fenwick tree"
	  },
	  "bellman-ford": {
		"prefix": "bellman",
		"body": [
		  "typedef struct EdgeInfo{",
		  "    ll from;",
		  "    ll to;",
		  "    ll cost;",
		  "    EdgeInfo() {};",
		  "    EdgeInfo(ll _from, ll _to, ll _cost) : from(_from), to(_to), cost(_cost) {};",
		  "} edge;",
		  "",
		  "/*",
		  "int main(){",
		  "",
		  "    ll N, M, P; ",
		  "    cin >> N >> M >> P;",
		  "    vector<edge> E(M);",
		  "    rep(i, 0, M){",
		  "        ll u, v, w;",
		  "        cin >> u >> v >> w;",
		  "        u--; v--;",
		  "        E[i] = edge (u, v, w);",
		  "    }",
		  "*/    ",
		  "    vector<ll> d(N, 1e18);",
		  "    bool closed_loop = false;",
		  "",
		  "    ll srt = 0;",
		  "    d[srt] = 0;",
		  "    rep(i, 0, N){",
		  "        rep(j, 0, M){",
		  "            auto e = E[j];",
		  "            if(d[e.to] > d[e.from] + e.cost){",
		  "                d[e.to] = d[e.from] + e.cost;",
		  "                if(i == N-1){",
		  "                    closed_loop = true;",
		  "                    break;",
		  "                }",
		  "            }",
		  "        }",
		  "        if(closed_loop) break;",
		  "    }",
		  "",
		  "/*",
		  "",
		  "    if(closed_loop) cout << -1 << endl;",
		  "    else cout << d[N-1] << endl;",
		  "",
		  "    return 0;",
		  "}",
		  "*/"
		],
		"description": ""
	  },
	  "baisu": {
		"prefix": "baisu",
		"body": [
		  "// low以上high以下のbaseの倍数の数",
		  "ll baisu(ll base, ll low, ll high){",
		  "    ll bt = (low + base - 1) / base;",
		  "    ll up = high / base;",
		  "    return up - bt + 1;",
		  "}"
		],
		"description": ""
	  },
	  "RMQ": {
		"prefix": "RMQ",
		"body": [
		  "",
		  "template <typename T> struct RMQ{",
		  "    ",
		  "    const ll NMAX = 1 << 17; // 131072",
		  "    const ll LL_MAX = 1e18 + 20;",
		  "    ll n;",
		  "    vector<T> dat;",
		  "",
		  "    RMQ(ll _n){",
		  "        n = 1;",
		  "        // 2^pまでpaddingする",
		  "        while(n < _n) n *= 2;",
		  "        // 初期化",
		  "        dat.resize((2 * NMAX - 1), LL_MAX);",
		  "    }",
		  "",
		  "    RMQ(ll _n, T _ini_val){",
		  "        n = 1;",
		  "        // 2^pまでpaddingする",
		  "        while(n < _n) n *= 2;",
		  "        // 初期化",
		  "        dat.resize((2 * NMAX - 1), LL_MAX);",
		  "        for(ll i = 0; i < 2 * n - 1; i++) dat[i] = _ini_val;",
		  "    }",
		  "",
		  "    void update(ll k, T a){",
		  "        k += n - 1;",
		  "        dat[k] = a;",
		  "        while(k > 0){",
		  "            k = (k-1) / 2;",
		  "            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);",
		  "        }",
		  "    }",
		  "",
		  "    T query(ll a, ll b, ll k, ll l, ll r){",
		  "        // [a, b) の最小値を求める．",
		  "        // k := nodeの番号",
		  "        // kが[l, r)に対応している．",
		  "        // query(a, b, 0, 0, n)で外から呼ぶ",
		  "        ",
		  "        // [a, b)と[l，r)が交差しないケース",
		  "        if(r <= a || b <= l){",
		  "            return LL_MAX;",
		  "        }",
		  "",
		  "        if(a <= l && r <= b){",
		  "            // [a, b)を[l, r)含むケース",
		  "            return dat[k];",
		  "        }else{",
		  "            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);",
		  "            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);",
		  "            return min(vl, vr);",
		  "        }",
		  "    }",
		  "    ",
		  "    T query(ll a, ll b){",
		  "        return query(a, b, 0, 0, n);",
		  "    }",
		  "",
		  "};",
		  "/*",
		  "int main(){",
		  "    ll N, Q;",
		  "    cin >> N >> Q;",
		  "    RMQ<ll> sg(N, (1LL<<31) - 1);",
		  "    rep(q, 0, Q){",
		  "        ll comm, x, y;",
		  "        cin >> comm >> x >> y;",
		  "        if(comm == 0) sg.update(x, y);",
		  "        else cout << sg.query(x, y+1) << endl;",
		  "    }",
		  "    return 0;",
		  "}",
		  "*/"
		],
		"description": ""
	  },
	  "Segment_tree_kenchyon": {
		"prefix": "segmenttree",
		"body": [
		  "template<class Monoid> struct SegTree {",
		  "    using Func = function<Monoid(Monoid, Monoid)>;",
		  "    const Func F;",
		  "    const Monoid UNITY;",
		  "    int SIZE_R;",
		  "    vector<Monoid> dat;",
		  "    ",
		  "    SegTree(int n, const Func f, const Monoid &unity): F(f), UNITY(unity) { init(n); }",
		  "    void init(int n) {",
		  "        SIZE_R = 1;",
		  "        while (SIZE_R < n) SIZE_R *= 2;",
		  "        dat.assign(SIZE_R * 2, UNITY);",
		  "    }",
		  "    ",
		  "    /* set, a is 0-indexed */",
		  "    void set(int a, const Monoid &v) { dat[a + SIZE_R] = v; }",
		  "    void build() {",
		  "        for (int k = SIZE_R - 1; k > 0; --k)",
		  "            dat[k] = F(dat[k*2], dat[k*2+1]);",
		  "    }",
		  "    ",
		  "    /* update, a is 0-indexed */",
		  "    void update(int a, const Monoid &v) {",
		  "        int k = a + SIZE_R;",
		  "        dat[k] = v;",
		  "        while (k >>= 1) dat[k] = F(dat[k*2], dat[k*2+1]);",
		  "    }",
		  "    ",
		  "    /* get {min-value, min-index}, a and b are 0-indexed */",
		  "    Monoid get(int a, int b) {",
		  "        Monoid vleft = UNITY, vright = UNITY;",
		  "        for (int left = a + SIZE_R, right = b + SIZE_R; left < right; left >>= 1, right >>= 1) {",
		  "            if (left & 1) vleft = F(vleft, dat[left++]);",
		  "            if (right & 1) vright = F(dat[--right], vright);",
		  "        }                                                                                                              ",
		  "        return F(vleft, vright);",
		  "    }",
		  "    inline Monoid operator [] (int a) { return dat[a + SIZE_R]; }",
		  "    ",
		  "    /* debug */",
		  "    void print() {",
		  "        for (int i = 0; i < SIZE_R; ++i) {",
		  "            cout << (*this)[i];",
		  "            if (i != SIZE_R-1) cout << \",\";",
		  "        }",
		  "        cout << endl;",
		  "    }",
		  "};",
		  ""
		],
		"description": ""
	  },
	  "line_cross_check": {
		"prefix": "line_cross",
		"body": [
		  "typedef struct Point_Coordinates {",
		  "    double x, y;",
		  "} point;",
		  "",
		  "// 線分ab, cdが交差する場合True",
		  "// 端点が他方の線分上にある場合もTrue",
		  "bool judge(point a, point b, point c, point d){",
		  "    double s, t;",
		  "    s = (a.x - b.x) * (a.y - c.y) - (a.y - b.y) * (a.x - c.x);",
		  "    t = (a.x - b.x) * (a.y - d.y) - (a.y - b.y) * (a.x - d.x);",
		  "    if (s * t >= 0) return false;",
		  "",
		  "    s = (c.x - d.x) * (c.y - a.y) - (c.y - d.y) * (c.x - a.x);",
		  "    t = (c.x - d.x) * (c.y - b.y) - (c.y - d.y) * (c.x - b.x);",
		  "    if (s * t >= 0) return false;",
		  "    ",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "LCS": {
		"prefix": "LCS",
		"body": [
		  "string LCS(string s, string t){",
		  "    ll ns = s.size();",
		  "    ll nt = t.size();",
		  "    vector< vector<ll> > dp(ns+1, vector<ll> (nt+1, 0));",
		  "    // initilaize",
		  "    rep(i, 0, ns){",
		  "        if(s[i] == t[0]) dp[i][0] = 1;",
		  "    }",
		  "    rep(i, 0, nt){",
		  "        if(s[0] == t[i]) dp[0][i] = 1;",
		  "    }",
		  "    // build DP table",
		  "    rep(i, 1, ns){",
		  "        rep(j, 1, nt){",
		  "            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);",
		  "            if(s[i] == t[j]){",
		  "                dp[i][j] = dp[i-1][j-1] + 1;",
		  "            }",
		  "        }",
		  "    }",
		  "    // make LCS",
		  "    string ret;",
		  "    ll i = ns-1, j = nt-1;",
		  "    while(i >= 0 && j >= 0){",
		  "        if(s[i] == t[j]){",
		  "            ret.push_back(s[i]);",
		  "            i--; j--;",
		  "        }else{",
		  "            if(j == 0) i--;",
		  "            else if(i == 0) j--;",
		  "            else if(dp[i-1][j] > dp[i][j-1]) i--;",
		  "            else j--;",
		  "        }",
		  "    }",
		  "    return ret;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "2bugraph": {
		"prefix": "2bugraph",
		"body": [
		  "// 2部グラフの判定",
		  "// 使い方：colorを-1で初期化してください．",
		  "// 注意：連結かどうかに気をつけてください．",
		  "// 参考：https://qiita.com/drken/items/a803d4fc4a727e02f7ba#4-3-%E4%BA%8C%E9%83%A8%E3%82%B0%E3%83%A9%E3%83%95%E5%88%A4%E5%AE%9A",
		  "vector<ll> color;",
		  "bool is_2bu_graph(vector< vector<ll> >& G, ll now, ll col) {",
		  "    color[now] = col;",
		  "    for(auto g : G[now]) {",
		  "        if(color[g] != -1) {",
		  "            if(color[g] == col) return false;",
		  "            else continue;",
		  "        } else {",
		  "            if(!is_2bu_graph(G, g, 1-col)) return false;",
		  "        }",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "compare string": {
		"prefix": "string_comp",
		"body": [
		  "// a >= b ?",
		  "const string MININF = \"-\";",
		  "bool comp(string a, string b){",
		  "    if(b == MININF) return true;",
		  "    if(a == MININF) return false;",
		  "    if(a.size() > b.size()) return true;",
		  "    if(a.size() < b.size()) return false;",
		  "    rep(i, 0, a.size()){",
		  "        if(a[i] > b[i]) return true;",
		  "        if(a[i] < b[i]) return false;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": ""
	  },
	  "kruskal": {
		"prefix": "kruskal",
		"body": [
		  "struct union_find{",
		  "    vector<ll> parent;",
		  "    vector<ll> nums;",
		  "    union_find(ll n){",
		  "        parent.resize(n);",
		  "        nums.resize(n, 1LL);",
		  "        rep(i, 0, n) parent[i] = i;",
		  "    }",
		  "    ll root(ll x){",
		  "        if(parent[x] == x) return x;",
		  "        parent[x] = root(parent[x]);",
		  "        return parent[x];",
		  "    }",
		  "    void unite(ll x, ll y){",
		  "        ll rx = root(x);",
		  "        ll ry = root(y);",
		  "        if(rx != ry){",
		  "            parent[rx] = ry;",
		  "            nums[ry] += nums[rx];",
		  "        }",
		  "    }",
		  "    bool same(ll x, ll y){",
		  "        ll rx = root(x);",
		  "        ll ry = root(y);",
		  "        if(rx == ry) return true;",
		  "        return false;",
		  "    }",
		  "    ll size(ll x){",
		  "        return nums[root(x)];",
		  "    }",
		  "};  ",
		  "",
		  "typedef struct EdgeInfo{",
		  "    ll cost;",
		  "    ll srt;",
		  "    ll end;",
		  "    ll id;",
		  "    EdgeInfo() {;};",
		  "    EdgeInfo(ll _cost, ll _srt, ll _end, ll _id) : cost(_cost), srt(_srt), end(_end), id(_id) {};    ",
		  "    ~EdgeInfo() {;};",
		  "} edge;",
		  "bool operator<(const edge& t1, const edge& t2) { return (t1.cost < t2.cost); };",
		  "bool operator>(const edge& t1, const edge& t2) { return (t1.cost > t2.cost); };",
		  "bool operator<=(const edge& t1, const edge& t2) { return (t1.cost <= t2.cost); };",
		  "bool operator>=(const edge& t1, const edge& t2) { return (t1.cost >=t2.cost); };",
		  "",
		  "int main(){",
		  "    ll N, M;",
		  "    cin >> N >> M;",
		  "    vector<edge> E(M);",
		  "    rep(i, 0, M){",
		  "        ll s, t, w;",
		  "        cin >> s >> t >> w;",
		  "        // if inputs are 1-indexed, enable following line.",
		  "        // s--; t--;",
		  "        E[i] = edge(w, s, t, i);",
		  "    }",
		  "    sort(E.begin(), E.end());",
		  "    ll ans = 0;",
		  "    struct union_find t(N);",
		  "    set<ll> used_edges;",
		  "    rep(i, 0, M){",
		  "        if(!t.same(E[i].srt, E[i].end))",
		  "        {",
		  "            ans += E[i].cost;",
		  "            t.unite(E[i].srt, E[i].end);",
		  "            used_edges.insert(E[i].id);",
		  "        }",
		  "    }",
		  "    cout << ans << endl;",
		  "    return 0;",
		  "}"
		],
		"description": ""
	  },
	  "dijkstra_function": {
		"prefix": "dijkstra_function",
		"body": [
		  "/*",
		  "Arguments:",
		  "- G   : 隣接リスト {destination edge, cost}",
		  "- d   : srtからの距離 <- これを変更する",
		  "- srt : 始点",
		  "*/",
		  "",
		  "void dijkstra(vector<vector<pair<ll,ll>>> G, vector<ll> &d, ll srt){",
		  "    priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>>> que;",
		  "    que.push({0, srt});",
		  "    d[srt] = 0;",
		  "    while(!que.empty()){",
		  "        auto q = que.top();",
		  "        que.pop();",
		  "        if(q.first > d[q.second]) continue;",
		  "        for(auto g : G[q.second]){",
		  "            if(d[g.first] <= q.first + g.second) continue;",
		  "            d[g.first] = q.first + g.second;",
		  "            que.push({d[g.first], g.first});",
		  "        }",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "runlength": {
		"prefix": "runlength",
		"body": [
		  "/*",
		  "How to use:",
		  "- input :   std::string",
		  "- output :  std::vector<std::pair<char, long long>>",
		  "    - first:    character",
		  "    - second:   count",
		  "",
		  "Note that any element of input must not be -1.",
		  "*/",
		  "vector<pair<char,ll>> run_length_encoding(string s){",
		  "    vector<pair<char,ll>> res;",
		  "    ll n = s.size();",
		  "    char prev = -1;",
		  "    ll cur = 1;",
		  "    for(ll i = 0; i < n; i++) {",
		  "        if(prev == s[i]) cur++;",
		  "        else {",
		  "            if(prev != -1) res.push_back({prev, cur});",
		  "            prev = s[i];",
		  "            cur = 1;",
		  "        } ",
		  "    }",
		  "    res.push_back({prev, cur});",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "set grep2vec": {
		"prefix": "set_grep",
		"body": [
		  "/*",
		  "Function:",
		  "    - insert `num` elements from `st.begin()` into vector and return it/",
		  "Requirement:",
		  "    - num <= st.size()",
		  "    - if num > st.size(), print error message and return vector contains all of `st` elements.",
		  "*/",
		  "template<typename T> vector<T> grep2vec(set<T> &st, ll num){",
		  "    if(num > st.size()) {",
		  "        cerr << \"WARNIG [grep2vec] : Too large `num` for `st.size()`. \" << endl;",
		  "    }",
		  "    vector<T> res;",
		  "    auto itr = st.begin(); ",
		  "    for(ll i = 0; i < min(num, (ll)st.size()); i++) {",
		  "        res.push_back(*itr);",
		  "        itr++;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "/*",
		  "Function:",
		  "    - insert `num` elements from `st.rbegin()` into vector and return it/",
		  "Requirement:",
		  "    - num <= st.size()",
		  "    - if num > st.size(), print error message and return vector contains all of `st` elements.",
		  "*/",
		  "template<typename T> vector<T> rgrep2vec(set<T> &st, ll num){",
		  "    if(num > st.size()) {",
		  "        cerr << \"WARNIG [rgrep2vec] : Too large `num` for `st.size()`. \" << endl;",
		  "    }",
		  "    vector<T> res;",
		  "    auto itr = st.rbegin(); ",
		  "    for(ll i = 0; i < min(num, (ll)st.size()); i++) {",
		  "        res.push_back(*itr);",
		  "        itr++;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  },
	  "str2dec": {
		"prefix": "str2dec",
		"body": [
		  "/*",
		  "オーバーフローには気を付けよう！",
		  "Inputs:",
		  "    string s : string representing a decimal number, such as 123.4, 0.123, 123.",
		  "    logn long shift_size : shift size, formally, this function return s * 10 ^ shift_size.",
		  "Output:",
		  "    Return s * 10 ^ shift_size as long long.",
		  "*/",
		  "long long str2dec(string s, long long shift_size) {",
		  "    auto pos = s.find('.');",
		  "    if(pos == string::npos) return atoll(s.c_str()) * pow(10LL, shift_size); // If s is an integer",
		  "    long long res = atoll(s.substr(0, pos).c_str()) * pow(10LL, shift_size); ",
		  "    res += atoll(s.substr(pos+1, s.size()-pos-1).c_str()) * pow(10LL, shift_size - (s.size()-pos-1));",
		  "    return res;",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "split": {
		"prefix": "split",
		"body": [
		  "// python でいうところの s.split(c)",
		  "vector<string> split(string s, char c){",
		  "    vector<string> res;",
		  "    s.push_back(c); // 番兵",
		  "    ll n = s.size();",
		  "    string cur;",
		  "    for(ll i = 0; i < n; i++) {",
		  "        if(s[i] == c) {",
		  "            res.push_back(cur);",
		  "            cur = \"\";",
		  "        } else {",
		  "            cur.push_back(s[i]);",
		  "        }",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": ""
	  }, 
	  "osa_k": {
		"prefix": "osa_k_prime_factorize",
		"body": [
		  "/* --------- ここから --------- */",
		  "using ll = long long;",
		  "",
		  "#define PRIME_FACTORIZE_MAX 2000010",
		  "ll primes[PRIME_FACTORIZE_MAX];",
		  "",
		  "void pre_osa_k() {",
		  "    for(ll i = 0; i < PRIME_FACTORIZE_MAX; i++) {",
		  "        primes[i] = 1;",
		  "    }",
		  "    for(ll i = 2; i < PRIME_FACTORIZE_MAX; i++) {",
		  "        if(primes[i] != 1) continue;",
		  "        for(ll j = i; j <= PRIME_FACTORIZE_MAX; j += i) {",
		  "            primes[j] = i;",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "vector<pair<ll,ll>> factorize(ll n){",
		  "    vector<pair<ll,ll>> res;",
		  "    while(n != 1) {",
		  "        ll cur = primes[n];",
		  "        ll cnt = 0;",
		  "        while(n % cur == 0) {",
		  "            n /= cur;",
		  "            cnt++;",
		  "        }",
		  "        res.push_back({cur, cnt});",
		  "    }",
		  "    reverse(res.begin(), res.end());",
		  "    return res;",
		  "}",
		  "/* --------- ここまで --------- */"
		],
		"description": ""
	  }
}